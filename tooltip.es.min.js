
/**
@draggable/tooltip - https://github.com/Draggable/tooltip
Version: 1.1.1
Author: Draggable https://draggable.io
*/


!function(){"use strict";try{if("undefined"!=typeof document){var t=document.createElement("style");t.appendChild(document.createTextNode('._3x4ZIcu-{position:absolute;background:#1f2937;color:#fff;padding:.75rem;border-radius:.375rem;max-width:200px;z-index:50;visibility:hidden;opacity:0;transition:opacity .2s}._3x4ZIcu-.JIt36hCJ{visibility:visible;opacity:1}._3x4ZIcu-:before{content:"";position:absolute;width:0;height:0;border:6px solid transparent}._3x4ZIcu-[data-position=top]:before{border-top-color:#1f2937;bottom:-12px;left:50%;transform:translate(-50%)}._3x4ZIcu-[data-position=bottom]:before{border-bottom-color:#1f2937;top:-12px;left:50%;transform:translate(-50%)}._3x4ZIcu-[data-position=left]:before{border-left-color:#1f2937;right:-12px;top:50%;transform:translateY(-50%)}._3x4ZIcu-[data-position=right]:before{border-right-color:#1f2937;left:-12px;top:50%;transform:translateY(-50%)}')),document.head.appendChild(t)}}catch(o){console.error("vite-plugin-css-injected-by-js",o)}}();
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const tooltip = "_3x4ZIcu-";
const visible = "JIt36hCJ";
const styles = {
  tooltip,
  visible
};
const defaultOptions = {
  triggerName: "tooltip"
};
class SmartTooltip {
  constructor(options = defaultOptions) {
    __publicField(this, "triggerName");
    __publicField(this, "tooltip");
    __publicField(this, "activeTriggerType", null);
    __publicField(this, "spacing", 12);
    __publicField(this, "handleClick", (e) => {
      const triggerName = this.triggerName;
      const trigger = e.target.closest(`[${triggerName}][${triggerName}-type="click"]`);
      if (trigger) {
        if (this.isVisible()) {
          this.hide();
        } else {
          const content = trigger.getAttribute(`${triggerName}`);
          this.show(trigger, content);
          this.activeTriggerType = "click";
        }
      } else {
        this.hide();
      }
    });
    __publicField(this, "handleMouseOver", (e) => {
      const triggerName = this.triggerName;
      const trigger = e.target.closest(`[${triggerName}]`);
      if (this.activeTriggerType !== "click" && (trigger == null ? void 0 : trigger.getAttribute(`${triggerName}-type`)) !== "click") {
        const content = trigger == null ? void 0 : trigger.getAttribute(`${triggerName}`);
        if (content) {
          this.show(trigger, content);
          this.activeTriggerType = "hover";
        }
      }
    });
    __publicField(this, "handleMouseOut", (e) => {
      const triggerName = this.triggerName;
      const trigger = e.target.closest(`[${triggerName}]`);
      if (this.activeTriggerType !== "click" && (trigger == null ? void 0 : trigger.getAttribute(`${triggerName}-type`)) !== "click") {
        this.hide();
      }
    });
    __publicField(this, "handleResize", () => {
      if (this.isVisible()) {
        this.hide();
      }
    });
    __publicField(this, "handleScroll", () => {
      if (this.isVisible()) {
        this.hide();
      }
    });
    this.triggerName = `data-${options.triggerName}`;
    this.tooltip = document.createElement("div");
    this.tooltip.className = styles.tooltip;
    document.body.appendChild(this.tooltip);
    this.setupEventListeners();
  }
  setupEventListeners() {
    document.addEventListener("mouseover", this.handleMouseOver);
    document.addEventListener("mouseout", this.handleMouseOut);
    document.addEventListener("click", this.handleClick);
    window.addEventListener("resize", this.handleResize);
    window.addEventListener("scroll", this.handleScroll, true);
  }
  isVisible() {
    return this.tooltip.classList.contains(styles.visible);
  }
  calculatePosition(trigger) {
    const triggerRect = trigger.getBoundingClientRect();
    const tooltipRect = this.tooltip.getBoundingClientRect();
    const positions = [
      {
        name: "top",
        x: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2,
        y: triggerRect.top - tooltipRect.height - this.spacing
      },
      {
        name: "bottom",
        x: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2,
        y: triggerRect.bottom + this.spacing
      },
      {
        name: "left",
        x: triggerRect.left - tooltipRect.width - this.spacing,
        y: triggerRect.top + (triggerRect.height - tooltipRect.height) / 2
      },
      {
        name: "right",
        x: triggerRect.right + this.spacing,
        y: triggerRect.top + (triggerRect.height - tooltipRect.height) / 2
      }
    ];
    return positions.find((pos) => this.fitsInViewport(pos, tooltipRect)) || positions[0];
  }
  fitsInViewport(pos, tooltipRect) {
    return pos.x >= 0 && pos.y >= 0 && pos.x + tooltipRect.width <= window.innerWidth && pos.y + tooltipRect.height <= window.innerHeight;
  }
  show(trigger, content) {
    this.tooltip.innerHTML = content ?? "";
    this.tooltip.classList.add(styles.visible);
    const position = this.calculatePosition(trigger);
    this.tooltip.style.left = `${position.x}px`;
    this.tooltip.style.top = `${position.y}px`;
    this.tooltip.dataset.position = position.name;
  }
  hide() {
    this.tooltip.classList.remove(styles.visible);
    this.activeTriggerType = null;
  }
  destroy() {
    document.removeEventListener("mouseover", this.handleMouseOver);
    document.removeEventListener("mouseout", this.handleMouseOut);
    document.removeEventListener("click", this.handleClick);
    window.removeEventListener("resize", this.handleResize);
    window.removeEventListener("scroll", this.handleScroll, true);
    this.tooltip.remove();
  }
}
if (window !== void 0) {
  window.SmartTooltip = SmartTooltip;
}
export {
  SmartTooltip,
  SmartTooltip as default
};
